

//============================ useMemo
//============================ useMemo

useMemo 用来缓存计算结果的

用来缓存计算结果，避免在每次组件渲染时重复做耗时计算。

//============================ 格式
//============================ 格式

const result = useMemo(() => {
  // 这里写计算逻辑
  return 计算结果;
}, [依赖变量1, 依赖变量2]);

第一个参数：一个函数，返回要缓存的值

第二个参数：依赖数组，只有依赖变化时才会重新计算

//============================ 为什么需要它
//============================ 为什么需要它
React 每次渲染组件时，函数体里的代码会全部重新执行，如果你有个计算特别耗时，比如：
	处理一份 10 万行的文件
	做复杂的对比（像你 getCompareData 这种差异分析）
	过滤、排序大量数据

没有 useMemo 的话，每次渲染都会重新算一次，非常浪费性能。
useMemo 的作用就是记住上次的计算结果，如果依赖没变，就直接用上次的值，不重新算。

//============================ 例子 没用 useMemo（每次渲染都计算）
//============================ 例子 没用 useMemo（每次渲染都计算）
没用 useMemo（每次渲染都计算）
const sortedList = bigList.sort((a, b) => a.value - b.value);

不管 bigList 有没有变，只要组件渲染，这个排序都会执行。


//============================ 例子 用 useMemo（依赖不变就不算）
//============================ 例子 用 useMemo（依赖不变就不算）
const sortedList = useMemo(() => {
  console.log('执行排序...');
  return bigList.sort((a, b) => a.value - b.value);
}, [bigList]);

只有 bigList 变了，才会执行 console.log 里的逻辑；否则直接用上一次缓存的结果。



//============================ 常见用途
//============================ 常见用途
性能优化：大计算量数据处理（排序、过滤、格式化等）

避免不必要的子组件渲染（因为引用没变）

依赖复杂对象时，保证对象引用稳定


