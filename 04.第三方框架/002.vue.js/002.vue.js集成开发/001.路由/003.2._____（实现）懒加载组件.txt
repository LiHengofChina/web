

在 Vue 应用中，通过 Vue Router 配合 Webpack 的  "动态导入功能" ，
可以实现 "懒加载组件"。

//============================================ 例如：
//============================================ 例如：

import { createRouter, createWebHistory } from 'vue-router';

const Home = () => import(/* webpackChunkName: "home" */ '../components/HelloWorld.vue');
const ApprovalForm = () => import(/* webpackChunkName: "approval" */ '../components/ApprovalForm.vue');

const routes = [
  { path: '/', name: 'Home', component: Home },
  { path: '/approval', name: 'Approval', component: ApprovalForm }
];

const router = createRouter({
  history: createWebHistory(process.env.BASE_URL),
  routes
});

export default router;

//============================================================================================================
//============================================================================================================

/* webpackChunkName: "home" */ 注释是可选的，但它确实在某些情况下非常有用。
							   它指定了一个名为 "home" 的代码块，

//============================================================================================================
//============================================================================================================
这个例子中，Home 和 ApprovalForm 组件都是 "通过动态导入的方式实现" 的 "懒加载"。
这意味着，这些组件的代码只会在 "用户访问相应的路由" 时才会被加载。


//============================================================================================================ 另外：核心组件不要使用懒加载
//============================================================================================================ 另外：核心组件不要使用懒加载

import { createRouter, createWebHistory } from 'vue-router';


这行代码不适合用 "懒加载" 的方式来写。
"懒加载" 通常用于 "加载组件或模块" 的代码，
而 vue-router 是一个 "核心依赖"，通常在 "应用启动时" 就需要加载。


import store from './store' 
	//import store from './store' 也是一个核心依赖。它通常用于导入 Vuex 的 store 实例，管理应用的全局状态。

import '@fortawesome/fontawesome-free/css/all.css';
	//这不是核心依赖，但它通常在应用启动时就需要加载，以确保在应用的所有部分都能正常显示图标。
	//因为 CSS 样式表的加载通常不会对性能产生显著影响（尤其是这种广泛使用的全局样式表），因此通常不会对它进行懒加载。



//============================================================================================================
//============================================================================================================


我的js是懒加载的const LoginPage = () => import(/* webpackChunkName: "log" */ '@/components/LoginPage.vue');，而js中又懒加载了图片
	组件懒加载：通过使用动态 import() 语法，只有在需要时才加载组件的 JavaScript 代码。
	这减少了初始加载的资源量，尤其是对于大型应用或包含许多路由的单页面应用（SPA），显著缩短了初始加载时间。

（1）组件懒加载：通过使用动态 import() 语法，只有在需要时才加载组件的 JavaScript 代码。
			这减少了初始加载的资源量，尤其是对于大型应用或包含许多路由的单页面应用（SPA），显著缩短了初始加载时间。

（2）图片懒加载：在组件内部延迟加载图片，只有 "在图片即将进入视口" 时才加载。这减少了不必要的图片加载，从而节省带宽和提升用户体验，
			特别是在包含大量图片的页面中。

//============================================================================================================ 从F12看出图片是懒加载的
//============================================================================================================ 从F12看出图片是懒加载的


查网络请求时间点：懒加载图片的请求通常在页面其他部分内容加载后发起，
			      具体时间点会略有延迟。这些请求不应该立即在页面加载时发出。

		//但是，在不使用懒加载的情况下，图片的加载顺序仍然相对靠后。这可能是由于浏览器的默认行为，
		//先处理和加载其他更重要的资源（如 JavaScript、CSS 等），之后再加载较大的图像资源。


//============================================================================================================ 两各动态导入
//============================================================================================================ 两各动态导入


const api = () => import('@/api/login/index');
const { default: api } = await import('@/api/login/index'); 


//==========================================立即调用的动态导入
//==========================================立即调用的动态导入

const { default: api } = await import('@/api/login/index');
	//这行代码表示立即进行动态导入。
	//await import('@/api/login/index') 会返回一个 Promise，该 Promise 解决时包含导入模块的所有导出内容。

	//{ default: api } 是对象解构赋值语法，用于提取默认导出（default）并将其赋值给 api 变量。

	//由于使用了 await，代码会等待导入完成，然后继续执行。这要求代码必须在 async 函数中，因为 await 只能在 async 函数内使用。

	//===========使用场景
	//===========使用场景
	立即需要模块: 适用于在调用点立即需要使用该模块的情况下，例如在函数中需要立即调用模块的某个方法。
	同步风格: 使用 await 可以让异步代码看起来像同步代码，有助于减少嵌套，提升可读性。
	//=========== 示例
	//=========== 示例
    async submitLogin() {
      try {

          const { default: api } = await import('@/api/login/index');//动态导入

          const response = await api.login(this.opNo, this.password);//调用登陆接口
          console.log('Login successful:', response);

          this.$router.push('/');

      } catch (error) {
          console.error('Login failed:', error);
      }
    },

//========================================== 延迟执行的动态导入
//========================================== 延迟执行的动态导入

	const api = () => import('@/api/login/index');
	解释
	（1）这行代码定义了一个函数 api，该函数返回调用 import('@/api/login/index') 的结果。
		 这里并未实际执行导入操作，而是定义了一个函数，当你调用 api() 时才会执行动态导入。

	（2）这种方式不会立即等待或获取模块，而是将获取模块的操作推迟到调用 api() 时。
	//===========使用场景
	//===========使用场景
	延迟加载: 适用于在某些条件下或事件触发时才需要导入模块的场景，例如在用户交互（如按钮点击）后才导入模块。
	控制导入时机: 通过延迟调用，可以精确控制导入模块的时机，从而优化资源加载和性能。

	//=========== 示例
	//=========== 示例
	const Home = () => import(/* webpackChunkName: "home" */ '@/components/HomePage.vue');
	const LoginPage = () => import(/* webpackChunkName: "log" */ '@/views/login/LoginPage.vue');

	const routes = [
		{
			path: '/',
			name: 'Home',
			component: Home
		},
		{
			path: '/login',
			name: 'LoginPage',
			component: LoginPage,
		}
	];
