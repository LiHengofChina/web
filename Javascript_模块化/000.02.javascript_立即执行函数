//===========================================立即执行函数是什么
//===========================================立即执行函数是什么

	1).声明一个匿名函数
	2).马上调用这个匿名函数

		(function(){
			
		})();

//===========================================为什么还要用另一对括号把匿名函数包起来？
//===========================================为什么还要用另一对括号把匿名函数包起来？

是为了兼容 JS 的语法。如果我们不加另一对括号，直接写成
function(){alert('我是匿名函数')}()浏览器会报语法错误。
// 由于括弧()和JS的&&，异或，逗号等操作符是在“函数表达式”和“函数声明”上消除歧义的
// 所以一旦解析器知道其中一个已经是表达式了，其它的也都默认为表达式了
想要通过浏览器的语法检查，必须加点小东西，比如下面几种


(function(){console.log("我是立刻执行函数");}());// 用括号把整个表达式包起来
(function(){console.log("我是立刻执行函数");})();//用括号把函数包起来 
!function(){console.log("我是立刻执行函数");}();// 求反，我们不在意值是多少，只想通过语法检查。
+function(){console.log("我是立刻执行函数");}();
-function(){console.log("我是立刻执行函数");}();
~function(){console.log("我是立刻执行函数");}();
var liheng = function(){console.log("我是立刻执行函数");}();
true && function(){console.log("我是立刻执行函数");}();
0 , function(){console.log("我是立刻执行函数");}();
void function(){console.log("我是立刻执行函数");}();
new function(){console.log("我是立刻执行函数");}()
	
//===========================================立即执行函数有什么用？
//===========================================立即执行函数有什么用？
	只有一个作用：创建一个独立的作用域。
	这个作用域里面的变量，外面访问不到（即避免「变量污染」）。
	//================示例：
		var liList = ul.getElementsByTagName('li')
		for(var i=0; i<6; i++){
		  liList[i].onclick = function(){
			alert(i) // 为什么 alert 出来的总是 6，而不是 0、1、2、3、4、5
			/**
				alert(i);
				里面的i是在运行的时候才去取i的值。而i已经变成了最终的值。
			*/
		  }
		}	
	 //================为了解决这个问题
		var liList = ul.getElementsByTagName('li')
		for(var i=0; i<6; i++){
		  !function(ii){
			  liList[ii].onclick = function(){
				alert(ii) // 0、1、2、3、4、5
			  }
		  }(i);
		}		 
	  i 的值从 0 变化到 5，对应 6 个立即执行函数，
	  这 6 个立即执行函数里面的 ii 「分别」是 0、1、2、3、4、5。
