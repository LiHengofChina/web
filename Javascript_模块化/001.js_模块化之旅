//================================================= 背景
//================================================= 背景
随着网站逐渐变成"互联网应用程序"，嵌入网页的Javascript代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等......开发者不得不使用软件工程的方法，管理网页的业务逻辑。Javascript模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。

//================================================= 原由
//================================================= 原由
在ES6之前，Javascript不是一种模块化编程语言，它不支持"类"（class），更别论"模块"（module）了。
ES6将会支持模块化的语法


"模块"就是"实现特定功能的一组方法"，只要把"不同的函数、以及记录状态的变量"简单地放在一起，就算是一个"模块"。

//================================================= 一阶段：原始写法 ："污染"全局变量
//================================================= 一阶段：原始写法 ："污染"全局变量
　　function method1(){
　　　　//...
　　}
　　function method2(){
　　　　//...
　　}
/**
	说明：
		函数method1()和method2()，组成一个模块。
		使用的时候，直接调用就行了。
		这种做法的缺点很明显："污染"了全局变量，
		无法保证不与其他模块发生变量名冲突，
		而且模块成员之间看不出直接关系。
*/
//================================================= 二阶段：对象写法 ：暴露"所有"模块成员
//================================================= 二阶段：对象写法 ：暴露"所有"模块成员
//解决了阶段一的缺点

　　var module1 = new Object({
　　　　_count : 0,
　　　　method1 : function (){
　　　　　　//...
　　　　},
　　　　method2 : function (){
　　　　　　//...
　　　　}
　　});
/** 
	说明：
		函数method1()和method2(），都封装在module1对象里。
		使用的时候，就是调用这个对象的属性。
		module1.method();但是，这样的写法会暴露所有模块成员，
		内部状态可以被外部改写。
		比如，外部代码可以直接改变内部计数器的值。module1._count = 5;
		
		//这种写法在ES5中又叫命名空间
*/


//================================================= 三阶段：立即执行函数 写法 ：解决暴露私有成员的问题。
//================================================= 三阶段：立即执行函数 写法 ：解决暴露私有成员的问题。
	var module1 = (function(){
		var _count = 0 ;
		var m1 = function (){
			console.log("__________m1");
		};
		var m2 =function (){
			console.log("__________m2");
		};
		return {
			m1: m1,
			m2: m2
		}
	})();
	module1.m1();
	module1.m2();

	使用"立即执行函数"（Immediately-Invoked Function Expression，IIFE），
	可以达到不暴露私有成员的目的。

	console.log(module1._count);//undefined
	
	
//================================================= 四阶段：放大模式：加入继承
//================================================= 四阶段：放大模式：加入继承

如果一个模块很大，必须分成几个部分，
或者一个模块需要继承另一个模块，
这时就有必要采用"放大模式"（augmentation）。

var module1 = (function (mod){
	mod.m3 = function(){
		console.log("__________m3");
	}
	return mod;	
})(module1);

module1.m1();
module1.m2();
module1.m3();

为module1模块添加了一个新方法m3()，然后返回新的module1模块。


//================================================= 五阶段：宽放大模式（Loose augmentation）
//================================================= 五阶段：宽放大模式（Loose augmentation）

在浏览器环境中，模块的各个部分通常都是从网上获取的，
有时无法知道哪个部分会先加载。
如果采用上一节的写法，第一个执行的部分有可能加载一个不存在空对象，
这时就要采用"宽放大模式"。


     var module1 = ( function (mod){
		//...
		return mod;
     })(window.module1 || {});



//================================================= 六阶段： 输入全局变量
//================================================= 六阶段： 输入全局变量

独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。
为了在模块内部调用全局变量，必须显式地将其他变量输入模块。


    var module1 = (function ($, YAHOO) {
 
    })(jQuery, YAHOO);






 

 
 
 
 
