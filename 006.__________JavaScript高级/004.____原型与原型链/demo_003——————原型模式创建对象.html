<!Doctype html>

<script type="text/javascript">

/**
	
	//==========================================================================
	//==========================================================================
	使用构造函数的问题是，"每个方法" 都要在 "每个实例" 上 "重新创建一遍"，
		即在 "构造函数" 的 "不同实例" 上的 "同名函数" 是不相等的。
			//*****这里构造函数就像是JAVA中类定义，每次new出来的对象就是它的实例 *****
	
	
	（1）. 说的是 "构造函数"
		而我们创建 "每个构造函数" 都有一个 prototype(原型)属性，这个属性是个指针，指向一个对象，
		而 "这个对象" 的用途是：包含可以由 "特定类型" 的 "所有实例" 共享的属性和方法，

		我们使用 "这个原型对象" 来共享 "实例的属性和方法" 的 模式就叫 "原型模式"。
												//TODO：和JAVA的 享元模式有联系吗？2022年6月30日20:37:23 TODO
	（2）. 说的是 "构建函数"
		
		而 "每个实例" 内部都有一个指向 "原型对象" 的指针。
		
	//============ 总结就是：
	//============ 总结就是：
	 "构造函数" 有个 prototype 属性，是一个指针，指向原型对象。
	 "每个实例" 内部也有一个指针 __proto__ ，指向原型对象。
	
	//============= 反之
	//============= 反之
	 "原型对象"都有 constructor 属性，指向它的构建函数
	
		
*/

function Person(){

}

Person.prototype.name = '钟女士';
Person.prototype.age = 80;
Person.prototype.gender = '女';
Person.prototype.say = function(){
	alert("lihengxx");
}

var person = new Person();
person.say();
console.log(person);


//============================

console.log(Person.prototype);//构造函数的
console.log(person.__proto__);//实例对象的


console.log(person.__proto__.constructor);// 反之
console.log(Person.prototype.constructor);// 反之



 
 
 
/**

//============================================================================================== 简写原型模式


Person.prototype={
	   constructor:Person,
	   name:'钟女士',
	   age:80,
	   gender:'女'
}

每个原型对象都有constructor属性，

由于简写模式重写了 默认的 "prototype对象" ，所以constructor也会被重新定义，不再指向他的构造函数，
		//因为：Person.prototype = {} 这种写法，就是在重写默认的 "原型对象" 
这时，可以自己写一个constructor属性 "指向他的构造函数"

//============================================================================================== 在对象实例中，访问对象原型的方法


1、使用proto属性
此属性是浏览器支持的一个属性，并不是ECMAScript里的属性


2.Object.getPrototypeOf


3.使用constructor.prototype的方法
对于不支持proto的浏览器，可以使用constructor，访问到对象的构造函数，在用prototype访问到原型


*/


</script>


<html>

</html>
