
//========================================== 单线程
//========================================== 单线程

浏览器里的 "JavaScript 引擎（比如 Chrome 的 V8）" 是 单线程 的，
也就是说 "同一时刻只能执行一段 JS 代码" 。


所以不会出现 "多个线程同时改同一个变量" 的情况
（不像 Java、C++ 那样有多线程并发访问内存的风险）。


//========================================== 事件循环（Event Loop）
//========================================== 事件循环（Event Loop）
那为什么看起来还能 "并发" 呢？靠的是 事件循环。
（1）JS "主线程只负责" 执行代码。
（2）"其它事情'（比如定时器、网络请求、DOM 事件监听）'会交给浏览器的底层线程去处理。"
（3）当它们完成后，会把 "回调函数" 放进一个 "任务队列"。
（4）JS 引擎执行完当前的任务，就从队列里拿出下一个任务继续执行。

这样看起来就像在并发运行，但其实 JS 依然是 一次只跑一个任务。


//========================================== 对你代码的意义
//========================================== 对你代码的意义

像 setContentMap 这种更新操作，即使源和目标几乎同时触发，
也只是 排队进入事件循环，
React 在内部会按顺序把更新合并处理。
所以不会真的“同时改冲突”。


//==================================================================================== 个人理解
//==================================================================================== 个人理解


就是说：js中所有需要处理的事情放进一个 事件队列，另一边会专门执行事件队列，
它们是按顺序执行吗?放和执行是同一个线程吗

//========= 放进队列的过程
//========= 放进队列的过程
	（1）"放" 任务进队列这一步，通常是浏览器的，其他线程（比如定时器线程、网络线程、IO线程）在做。
	（2）它们 "不会直接执行" JS，只是把 "回调函数" 丢到一个 "任务队列" 里。
		例子：setTimeout(fn, 1000) 到时间了 → 浏览器底层计时器线程会把 fn 丢到队列里。

//========= 执行队列的过程
//========= 执行队列的过程
	"取" 任务并执行的只有一个：JS 主线程。
	主线程 "空闲下来" 时（当前任务执行完毕），会去队列里拿下一个任务，按顺序执行。

//========= 顺序
//========= 顺序

是 严格顺序：先进队列的任务，等主线程空闲时会按规则取出执行。

宏任务（如 setTimeout、setInterval、DOM 事件回调）先进先出。
微任务（如 Promise.then）会在当前宏任务执行结束后，立即清空再继续。

//========= 总结
//========= 总结

放和执行不是同一个线程：放任务的是浏览器的底层机制，执行的始终是 JS 主线程。
执行是顺序的：一次只执行一个任务，绝不会并发执行两个 JS 片段。

//==================================================================================== 个人理解2
//==================================================================================== 个人理解2

（1）放任务是浏览器本身启动时开启的某个底层线程，
（2）而JS代码(程序员写的代码)是js主线程执行，
	 在这个主线程可以调用某些方法如setTimeout操作浏览器本身的线程，
（3）另外js主线程在空闲时会去某个队列取任务执行

//==============
放任务：浏览器底层线程（计时器、网络等）负责把任务放进队列。
执行任务：JS 主线程只负责顺序取队列里的任务执行。
主线程空闲时才去取，永远单线程运行。

