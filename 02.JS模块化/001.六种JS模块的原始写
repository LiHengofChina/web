
//================================================= 一阶段：原始写法 ："污染"全局变量
//================================================= 一阶段：原始写法 ："污染"全局变量
　　function method1(){
　　　　//...
　　}
　　function method2(){
　　　　//...
　　}
/**
	说明：
		函数method1()和method2()，组成一个模块。
		使用的时候，直接调用就行了。
		这种做法的缺点很明显："污染"了全局变量，
		无法保证不与其他模块发生变量名冲突，
		而且模块成员之间看不出直接关系。
*/
//================================================= 二阶段：对象写法 ：暴露"所有"模块成员
//================================================= 二阶段：对象写法 ：暴露"所有"模块成员
//解决了阶段一的缺点

　　var module1 = new Object({
　　　　_count : 0,
　　　　method1 : function (){
　　　　　　//...
　　　　},
　　　　method2 : function (){
　　　　　　//...
　　　　}
　　});
/** 
	说明：
		函数method1()和method2(），都封装在module1对象里。
		使用的时候，就是调用这个对象的属性。
		module1.method();但是，这样的写法会暴露所有模块成员，
		内部状态可以被外部改写。
		比如，外部代码可以直接改变内部计数器的值。module1._count = 5;
		
		//这种写法在ES5中又叫命名空间
*/


//================================================= 三阶段：立即执行函数 写法 ：解决暴露私有成员的问题。
//================================================= 三阶段：立即执行函数 写法 ：解决暴露私有成员的问题。
	var module1 = (function(){
		var _count = 0 ;
		var method1 = function (){
			console.log("__________method1");
		};
		var method2 =function (){
			console.log("__________method2");
		};
		return {
			method1: method1,
			method2: method2
		}
	})();
	module1.method1();
	module1.method2();

	使用"立即执行函数"（Immediately-Invoked Function Expression，IIFE），
	可以达到不暴露私有成员的目的。

	console.log(module1._count);//undefined
	
	
//================================================= 四阶段：放大模式：加入继承
//================================================= 四阶段：放大模式：加入继承

如果一个模块很大，必须分成几个部分，
或者一个模块需要继承另一个模块，
这时就有必要采用"放大模式"（augmentation）。

var module1 = (function (mod){
	mod.method3 = function(){
		console.log("__________method3");
	}
	return mod;	
})(module1);

module1.method1();
module1.method2();
module1.method3();

为module1模块添加了一个新方法method3()，然后返回新的module1模块。


//================================================= 五阶段：宽放大模式（Loose augmentation）
//================================================= 五阶段：宽放大模式（Loose augmentation）

在浏览器环境中，模块的各个部分通常都是从网上获取的，
有时无法知道哪个部分会先加载。
如果采用上一节的写法，第一个执行的部分有可能加载一个不存在空对象，
这时就要采用"宽放大模式"。


     var module1 = ( function (mod){
		//...
		return mod;
     })(window.module1 || {});



//================================================= 六阶段： 输入全局变量
//================================================= 六阶段： 输入全局变量

独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。
为了在模块内部调用全局变量，必须显式地将其他变量输入模块。


    var module1 = (function ($, YAHOO) {
 
    })(jQuery, YAHOO);

