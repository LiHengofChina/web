/*
 * grunt-replace-url
 *
 *
 * Copyright (c) 2015 lanmb
 * Licensed under the MIT license.
 */

'use strict';

var fs = require('fs');
var path = require('path');
var iconv = require('iconv-lite');

var win_sep = '\\';
var posix_sep = '/';

// The module to be exported.
var deal = function (options, grunt) {
  this.options = grunt.util._.extend({
  }, options);

  // The default file encoding to use.
  var defaultEncoding = 'utf8';
  // Whether to preserve the BOM on file.read rather than strip it.
  var preserveBOM = false;
  var pathSeparatorRe = /[\/\\]/g;

  var dependencyPathPattern = new RegExp('(\'|")[\\w\\d-_/.!\\,\\:\\[\\]]+(\'|")', 'g');

  var cssUrlPattern = new RegExp('url\\s*\\(\\s*(' + dependencyPathPattern.source + ')\\s*\\)', 'ig');
  // e.g. url("./fonts/flaticon.svg")  or url('./fonts/flaticon.svg') or url(./fonts/flaticon.svg)
  var resourceUrlPattern = new RegExp('(href|src)\\s*=\\s*(' + dependencyPathPattern.source + ')\\s*', 'ig');

  //定义规则，业务需要，在js中定义的文件路径变量
  var fileUrlPattern = new RegExp('(\'|")(url|content)(\'|")\\s*:\\s*(' + dependencyPathPattern.source + ')', 'ig');

  /**
   * 将windows格式的路径转化为linux格式的路径
   * @param pathName  路径
   * @returns {*}
   */
  var parseLinuxPath = function (pathName) {
    if (typeof pathName === 'string') {
      return pathName.split(win_sep).join(posix_sep);
    }
    return pathName;
  };

  /**
   * 读取文件内容
   * @param filepath  文件路径
   * @param options   选项，可设置encoding格式
   * @returns {*}
   */
  var read = function (filepath, options) {
    if (!options) {
      options = {};
    }
    var contents;
    try {
      contents = fs.readFileSync(String(filepath));
      // If encoding is not explicitly null, convert from encoded buffer to a
      // string. If no encoding was specified, use the default.
      if (options.encoding !== null) {
        contents = iconv.decode(contents, options.encoding || defaultEncoding);
        // Strip any BOM that might exist.
        if (!preserveBOM && contents.charCodeAt(0) === 0xFEFF) {
          contents = contents.substring(1);
        }
      }
      return contents;
    } catch (e) {
      grunt.fail.warn('Unable to read "' + filepath + '" file (Error code: ' + e.code + ').', e);
    }
  };

  /**
   * 写文件
   * @param filepath 路径
   * @param contents 内容
   * @param options  选项
   * @returns {boolean}
   */
  var write = function (filepath, contents, options) {
    if (!options) {
      options = {};
    }
    // Create path, if necessary.
    mkdir(path.dirname(filepath));
    try {
      // If contents is already a Buffer, don't try to encode it. If no encoding
      // was specified, use the default.
      if (!Buffer.isBuffer(contents)) {
        contents = iconv.encode(contents, options.encoding || defaultEncoding);
      }
      fs.writeFileSync(filepath, contents);
      return true;
    } catch (e) {
      grunt.fail.warn('Unable to write "' + filepath + '" file (Error code: ' + e.code + ').', e);
    }
  };

  var exists = function () {
    var filePath = path.join.apply(path, arguments);
    return fs.existsSync(filePath);
  };

  var mkdir = function (dirpath, mode) {
    // Set directory mode in a strict-mode-friendly way.
    if (mode == null) {
      mode = parseInt('0777', 8) & (~process.umask());
    }
    dirpath.split(pathSeparatorRe).reduce(function (parts, part) {
      parts += part + '/';
      var subpath = path.resolve(parts);
      if (!exists(subpath)) {
        try {
          fs.mkdirSync(subpath, mode);
        } catch (e) {
          grunt.fail.warn('Unable to create directory "' + subpath + '" (Error code: ' + e.code + ').', e);
        }
      }
      return parts;
    }, '');
  };

  var getFiles = function (dir, files_) {
    files_ = files_ || [];
    //部分远程文件在本地可能不存在，使用正则表达式判断是否文文件
    var filePattern = new RegExp('[^\\.]+\\.[\\w]+$');
    var fielMatchs = dir.match(filePattern);
    if(!fielMatchs) {
      var files = fs.readdirSync(dir);
      for (var i in files) {
        var name = '';
        if (dir[dir.length - 1] === '/') {
          name = dir + files[i];
        }
        else {
          name = dir + posix_sep + files[i];
        }
        if (fs.statSync(name).isDirectory()) {
          getFiles(name, files_);
        } else {
          files_.push(name);
        }
      }
    } else {
      files_.push(dir);
    }

    return files_;
  };

  /**
   * 从fileItem的依赖Map中搜索是否依赖了targetPath文件
   * @param fileItem
   * @param targetPath
   * @returns {*}
   */
  this.matchPatternFromArray = function (fileItem, targetPath) {
    var dependencies = this.dependenciesMap[fileItem].dependencies;
    for (var i = 0; i < dependencies.length; i++) {
      var item = dependencies[i];
      //匹配路径中的第一项
      var extname = path.extname(item) !== '' ? '' : '.js';
      var needFromCwd = false;
      ////对于在require.js中直接使用了根目录下的文件路径，如fixtures/frameworkFixture.js，需要从cwd路径算起
      if (/^\s*\./g.test(item) === false) {
        needFromCwd = true;
      }
      if (path.extname(fileItem) === '.html') {
        needFromCwd = true;
      }
      var standardPath = '';
      if (needFromCwd) {
        standardPath = parseLinuxPath(path.join(this.options.cwd, item) + extname);
      }
      else {
        standardPath = parseLinuxPath(path.join(path.dirname(fileItem), item) + extname);
      }
      if (standardPath === targetPath) {
        return item;
      }
    }
    return null;
  };

  /**
   * 替换targetPath在其它文件中被依赖的路径, 需要遍历每个文件中的依赖Map
   * @param targetPath   文件全路径
   * @param targetHashPath  文件哈希全路径
   */
  this.replaceDependencyPath = function (targetPath, targetHashPath) {
    //找到该文件在其它使用文件中的依赖列表，然后修改依赖了该文件的文件内容
    for (var fileItem in this.dependenciesMap) {
      if (fileItem === targetPath) {
        continue;
      }
      if (/(.js|.css|.html)/.test(path.extname(fileItem)) === false) {
        continue;
      }
      var fileItemObj = this.dependenciesMap[fileItem];
      var dependencyMatch = this.matchPatternFromArray(fileItem, targetPath);
      if (dependencyMatch) {
        grunt.log.writeln('Replace require path for %s with %s ...', fileItem, targetPath);
        var contents = read(fileItem);
        grunt.log.writeln('in fileItemObj.hashFilePath =%s, replace dependencyMatch=%s to replacePath=%s', targetPath, dependencyMatch, targetHashPath);
        dependencyMatch = dependencyMatch.replace(new RegExp('\\.\\./', 'g'), '\\.\\./');
        write(fileItem, contents.replace(new RegExp(dependencyMatch, 'g'),targetHashPath));
      }
    }
  };

  function dealMainJsPath(dataMainPath, configFile, remotePaths, remoteResourcePath) {

    var dataMainDir = path.dirname(dataMainPath);
    var contents = read(configFile);

    var configJSON = JSON.parse(contents);

    contents = read(dataMainPath);
    //处理config.baseUrl
    var baseUrl = configJSON.baseUrl;
    //合并路径
    baseUrl = path.join(dataMainDir, baseUrl);
    var remoteUrl = remoteResourcePath;

    if(remoteUrl.charAt(remoteUrl.length-1) !== '/') {
      remoteUrl = remoteUrl + '/';
    }

    console.log("remoteUrl =" + remoteUrl);

    var pathPattern = new RegExp('(\'|")paths(\'|")\\s*:\\s*{[^}]*}', 'i');

    var pathMatches = contents.match(pathPattern);
    if(!pathMatches) {
      grunt.log.error('RegExp  %s match nothing in %s ...', pathPattern, dataMainPath);
      return;
    }

    ////处理config.paths
    var paths = {};
    for (var key in configJSON.paths) {
      console.log('key=' + key + ',flag=' + arrayContains(remotePaths, key));
      if(arrayContains(remotePaths, key) >=0 ) {
        var pathUrlPattern = new RegExp('(\'|")'+key+'(\'|")\\s*:\\s*(\'|")([^\'"]*)(\'|")', 'i');
        var pathUrlMatches = pathMatches[0].match(pathUrlPattern);
        if(pathUrlMatches) {
          var paths = pathUrlMatches[0].split(':');
          if(paths.length === 2) {
            var filePath = paths[1].replace(/^\s+/g, '').replace(/'|"/g, '');
            if(!filePath.match(/^http/)) {
              var newPathContent = '"'+key+'": "'+remoteUrl + filePath+'"';
              contents = contents.replace(pathUrlMatches[0], newPathContent);
            }
          } else {
            grunt.log.error('match result %s is invalid', pathUrlMatches);
          }
        } else {
          grunt.log.error('RegExp  %s match nothing in %s ...', pathUrlPattern, pathUrlMatches);
        }
      }
    }

    console.log(remotePaths);

    write(dataMainPath, contents);
  }

  function arrayContains(array, element) {
    for(var i=0; i<array.length; i++) {
      if(array[i] === element) {
        return i;
      }
    }

    return -1;
  }



  /**
   * 获取每个文件中的依赖Map
   * 1. 所有require 依赖
   * 2. require.config依赖
   * 3. lazy-load 依赖
   * 4. html 中所有图片，css, js依赖
   * 5. js 中指定规则url: "path" 的依赖
   * 6. css中的图片，字体文件依赖
   */
  this.getDependenciesMap = function () {
    var self = this;
    var targetFiles = this.files;
    var dependenciesMap = {};
    targetFiles.forEach(function (targetPath) {
      if (/(.js|.css|.html)/.test(path.extname(targetPath)) === false) {
        return;
      }
      grunt.log.writeln('Search Dependencies of targetPath: %s', targetPath);
      var contents = read(targetPath);

      // dependency path array
      var dependencies = [];

      if (path.extname(targetPath) === '.js') {
        var fileUrlMatches = contents.match(fileUrlPattern);
        grunt.log.writeln('fileUrl matches: %s', fileUrlMatches);
        if (fileUrlMatches) {
          fileUrlMatches.forEach(function (fileUrlMatch) {
            var pathMatches = fileUrlMatch.match(dependencyPathPattern);
            if (pathMatches) {
              dependencies = dependencies.concat(pathMatches);
            }
          });
        }
      }

      //如果是.js,.html,.css文件，需要记录该css文件中动态引入的图片和字符文件
      //注意如果是.js中引入的css样式中有图片依赖，那么路径必须是以根目录下的子目录为起始路径
      //e.g: $('<div>').css({"background": "#aaaaaa url('theme/default/images/mask-cover.png') 50% 50% repeat-x"});
      //不能是e.g: $('<div>').css({"background": "#aaaaaa url('./theme/default/images/mask-cover.png') 50% 50% repeat-x"});
      if (/(.js|.css|.html|)/.test(path.extname(targetPath)) === true) {
        var urlMatches = contents.match(cssUrlPattern);
        grunt.log.writeln('url matches: %s', urlMatches);
        if (urlMatches) {
          urlMatches.forEach(function (urlMatch) {
            var pathMatches = urlMatch.match(dependencyPathPattern);
            dependencies = dependencies.concat(pathMatches);
          });
        }
      }

      //如果是html文件，需要记录html文件中动态引入的图片和字符文件
      if (path.extname(targetPath) === '.html') {
        var resourcesMatches = contents.match(resourceUrlPattern);
        grunt.log.writeln('resources matches: %s', resourcesMatches);

        if (resourcesMatches) {
          resourcesMatches.forEach(function (resourceMatch) {
            var pathMatches = resourceMatch.match(dependencyPathPattern);
            if (pathMatches) {
              dependencies = dependencies.concat(pathMatches);
            }
          });
        }
      }

      // remove quotation mark
      for (var i = 0; i < dependencies.length; i++) {
        dependencies[i] = dependencies[i].replace(/'|"/g, '');
      }

      // remove duplicate dependency path
      for (var i = 0; i < dependencies.length; i++) {
        var target = dependencies[i];
        var indexOfNext = dependencies.indexOf(target, i + 1);
        if (indexOfNext > 0) {
          dependencies.splice(indexOfNext, 1);
          i--;
        }
      }
      dependenciesMap[targetPath] = {};
      dependenciesMap[targetPath].dependencies = dependencies;
    });
    this.dependenciesMap = dependenciesMap;
    console.dir(dependenciesMap);
  };

  this.getFilesFromOptionFiles = function(cwd, optionFiles) {
    var targetFiles = [];
    var excludeFiles = [];
    optionFiles.forEach(function (filePair) {
      filePair.src.forEach(function (src) {
        if( src && src.indexOf("!") === 0) {
          src = src.substring(1);
          getFiles(parseLinuxPath(path.join(cwd, src)), excludeFiles);
        }
        else {
          getFiles(parseLinuxPath(path.join(cwd, src)), targetFiles);
        }
      });
    });
    for(var i=0; i<excludeFiles.length; i++) {
      var target = excludeFiles[i];
      var indexOfNext = targetFiles.indexOf(target);
      if (indexOfNext >= 0) {
        targetFiles.splice(indexOfNext, 1);
      }
    }

    return targetFiles;
  }

  /**
   * 处理需要hash的所有路径
   */
  this.deal = function () {
      console.log(1111);
      var self = this;

      var remoteResourcePath;
      var remoteUrl = this.options.remoteUrl;
      if(!remoteUrl) {
        grunt.log.error('remoteUrl is undefined');
        return;
      }
      if(typeof remoteUrl == 'function') {
          remoteResourcePath = remoteUrl();
      } else {
          remoteResourcePath = remoteUrl;
      }

      if(!remoteResourcePath) {
        grunt.log.error('remoteResourcePath is null');
        return;
      }

      this.files = self.getFilesFromOptionFiles(self.options.cwd, this.options.targetFiles);
      this.getDependenciesMap();
      var targetFiles = self.getFilesFromOptionFiles(self.options.cwd, this.options.files);
      targetFiles.forEach(function (targetFile) {
          var remoteFile = targetFile.replace('build', remoteResourcePath);
          self.replaceDependencyPath(targetFile, remoteFile);
      });

      if(self.options.mainJs) {
        dealMainJsPath(self.options.mainJs.filePath,self.options.mainJs.configFile,
          self.options.mainJs.remotePaths, remoteResourcePath);
      }

    }
};

module.exports = function (grunt) {

  grunt.registerMultiTask('replace_url', 'none', function () {

    // Merge task-specific and/or target-specific options with these defaults.
    var options = this.options({
    });
    grunt.log.writeln(JSON.stringify(options));

    if (options.cwd === undefined) {
      grunt.fail.warn("cwd is undefined.");
    }
    var dealInstance = new deal(options, grunt);
    dealInstance.deal();
    grunt.log.ok('success hashed file');
  });

};
