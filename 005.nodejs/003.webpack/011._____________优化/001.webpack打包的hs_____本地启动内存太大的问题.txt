
 
（1）问题表面2 ：
	本地登陆时，显示：错误代码：Out of Memory

（2）问题表面3 ：
	  http://192.168.100.191/mftcc-web/static/js/app.js
	  //这个30M的js,加载到浏览器会显示它有2G的大小。
	  再加上 启用了 --inline 模式，会占用更多的内存

//===================================================================== 个人分析
//===================================================================== 个人分析
	（1）关闭inline
	（1）压缩js
	（2）添加 回事JS编译 速度的插件

//===================================================================== 注意
//===================================================================== 注意


"插件" 要使用 "对应的版本"


//===================================================================== 解决方案
//===================================================================== 解决方案

（1） 启用代码分割和 懒加载：
	  //TODO，这里只是分割了代码， 懒加载 要在代码中使用才行
	  通过代码分割将代码拆分成更小的块，只在需要时加载相应的代码模块。

		module.exports = {
			  // 其他配置
			  optimization: {
					splitChunks: {
					  chunks: 'all', // 处理同步和异步块
					  minSize: 20000, // 拆分前的最小模块大小（20 KB）
					  maxSize: 200000, // 拆分后的最大模块大小（200 KB）
					  minChunks: 1, // 模块最少被引用的次数
					  maxAsyncRequests: 30, // 最大异步请求数
					  maxInitialRequests: 30, // 最大初始请求数
					  automaticNameDelimiter: '~', // 名称分隔符
					  cacheGroups: {
						defaultVendors: {
						  test: /[\\/]node_modules[\\/]/, // 匹配node_modules目录下的模块
						  priority: -10 // 优先级
						},
						default: {
						  minChunks: 2, // 模块最少被引用的次数
						  priority: -20, // 优先级
						  reuseExistingChunk: true // 复用已经存在的块
						},
						vendors: {
						  test: /[\\/]node_modules[\\/]/, // 匹配node_modules目录下的模块
						  chunks: 'initial', // 处理初始块
						  name: 'vendors', // 块名称
						},
						'async-vendors': {
						  test: /[\\/]node_modules[\\/]/, // 匹配node_modules目录下的模块
						  minChunks: 2, // 模块最少被引用的次数
						  chunks: 'async', // 处理异步块
						  name: 'async-vendors' // 块名称
						}
					  }
					},
			  },
		};

（2） 压缩和混淆代码：
	  在生产环境中，确保使用压缩和混淆工具来减少代码大小。

		// npm install --save-dev terser-webpack-plugin
		// npm install --save-dev terser-webpack-plugin@4.2.3 //我使用的是这个版本


		const TerserPlugin = require('terser-webpack-plugin');

		module.exports = {
		  // 其他配置
		  optimization: {
			minimize: true,
			minimizer: [new TerserPlugin()],
		  },
		};


（3） （这个在测试环境使用）移除未使用的代码和依赖：//注意它只是用于分析打包输出，不会自动删除不需要的代码
	  使用 Webpack 插件如 webpack-bundle-analyzer 来分析打包后的文件，找出并移除未使用的代码和依赖。
	    // npm install --save-dev webpack-bundle-analyzer
		// npm install --save-dev webpack-bundle-analyzer@3.9.0 使用的是这个版本

		const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;

		module.exports = {
		  // 其他配置
		  plugins: [
			new BundleAnalyzerPlugin(),
		  ],
		};

（4） 优化静态资源：
	  使用压缩工具优化图片和其他静态资源。

	//npm install imagemin imagemin-mozjpeg imagemin-pngquant --save-dev

	//npm install --save-dev imagemin@8.0.0            我使用的是这个版本
	//npm install --save-dev imagemin-mozjpeg@8.0.0    我使用的是这个版本
	//npm install --save-dev imagemin-pngquant@8.0.0   我使用的是这个版本


	//npm install --save-dev imagemin-webpack-plugin
	//npm install --save-dev imagemin-webpack-plugin@2.4.0

	const ImageminPlugin = require('imagemin-webpack-plugin').default;

	module.exports = {
	  // 其他配置
	  plugins: [
		new ImageminPlugin({ test: /\.(jpe?g|png|gif|svg)$/i }),
	  ],
	};

（5）并行构建: 使用 thread-loader 或 parallel-webpack 来并行处理模块。
     npm install --save-dev thread-loader@2.1.3

	 module: {
		rules: [
			 ...utils.styleLoaders({ sourceMap: config.dev.cssSourceMap, usePostCSS: true }),
			  {
				test: /\.js$/,
				include: path.resolve(__dirname, 'src'),
				use: [
				  {
					loader: 'thread-loader',
					options: {
					  workers: 8, // 可以根据您的 CPU 核心数量调整
					},
				  },
				  'babel-loader',
				],
			  },
		]
	 },
