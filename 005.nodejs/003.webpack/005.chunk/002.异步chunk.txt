
https://www.cnblogs.com/powertoolsteam/p/10873677.html

//====================================================================== 动态导入 与webpack
//====================================================================== 动态导入 与webpack


在Webpack中使用动态导入，会新增一个chunk，我们视作异步chunk。
像这样的chunk会被打包进单独的文件。

当使用表达式创建指向其文件的路径时


let fileName = '';
 
document.addEventListener("DOMContentLoaded", () => {
		  const button = document.querySelector('#divideButton');
		  fileName = 'divide';
		  button.addEventListener('click', () => {
					import(`./utilities/${fileName}`)
					  .then(divideModule => {
								console.log(divideModule.divide(6, 3)); // 2
					  })
		  });
});

/**

以上代码在你的项目中被打包过后，你会发现Webpack在utilities文件夹下为每个模块单独创建了异步chunk
这是因为 Webpack 不能在 "编译时" 知道 "哪些模块需要被导入"。


你还需要知道像import(pathToFile)这样的完全的动态声明是不起作用的，因为Webpack至少需要一部分文件路径信息。
这是因为 pathToFile 可以是你工程中任何文件的路径，
而Webpack会为每个模块在给定的文件夹中创建异步chunk。

 
*/

你可以自定义此行为，我们下面就会这么做:

//================================================================================== 使用在Webpack中使用魔法注释
//================================================================================== 使用在Webpack中使用魔法注释

导入模块的规范不允许你在导入时使用除了文件名以外的参数。
幸运的是，有了Webpack，
你可以利用所谓的**魔法注释（magic comments）**来使用附加参数。


webpackInclude 和 webpackExclude

在之前，我们提到Webpack会为 "每个模块" 在 我们 "给定的文件夹中" 创建 "异步chunk"。
虽然这是默认行为，但它可以修改。

//=================================================================== webpackExclude
//=================================================================== webpackExclude
import(
  `./utilities/${fileName}`
  /* webpackExclude: /subtract.js$/ */
)

其中一种方法是使用 webpackExclude，它是一个正则表达式，
用以匹配潜在的可被导入的文件。任何"匹配到的文件" 都不会 被打包进来。 ********** 注意：是"不会"，因为它要进行异常chunk。
//=================================================================== webpackInclude
//=================================================================== webpackInclude

与之相反的一个参数叫做 webpackInclude。使用它时，只有匹配了正则表达式的模块会被打包。

//=================================================================== webpackMode
//=================================================================== webpackMode


webpackMode 属性定义了 resolve 动态模块时的模式。
	//======== lazy
	//======== lazy
	 这是默认模式。它为每个动态导入的模块创建异步chunk。

	 	
	//======== lazy-once
	//======== lazy-once
		使用它，会为满足导入条件的所有模块创建单一的异步chunk。

		import(
		  `./utilities/${fileName}`
		  /* webpackMode: "lazy-once" */
		)
					.then(divideModule => {
					console.log(divideModule.divide(6, 3)); // 2
		})
		以上代码表示，Webpack会为所有 utilities 目录下的所有模块共同创建一个异步chunk。
		它会导致用户以一个文件下载所有的模块。
		/**
			个人理解，应该是：使用import(`./utilities/${fileName}`) 本身就说明  utilities 全部是需要动态导入的内容了。
						而 lazy-once 会把它们打成一个文件。
				
		*/
	//========  eager
	//========  eager
		此模式会阻止Webpack生成额外的chunk。所有导入的模块被包含在当前chunk，
		所以不需要再发额外的网络请求。
		它仍然返回一个Promise，但它被自动resolve。
		//有什么区别呢？
		使用eager模式的动态导入与静态导入的区别在于
		整个模块只有当**import()**调用之后才执行。
		/**
			个人理解，应该是：这部分内容打包还是生成在一起，但它加载时机是 "点击按扭之后"
		*/
	//======== weak
	//======== weak

		彻底阻止额外的网络请求。
		只有当该模块已在其他地方被加载过了之后，Promise才被resolve，否则直接被reject。
//=================================================================== webpackChunkName
//=================================================================== webpackChunkName

	它是新chunk的名字，可以和[index]、[request]变量一起使用。
	[index]在当前动态导入声明中表示文件的索引。
	另一方面，[request]表示导入文件的动态部分。

	import(
	`./utilities/${fileName}`
		/* webpackChunkName: "utilities-[index]-[request]" */
	)
	请注意，如果在某些情况下，确定只有一个异步chunk（比如本来就没有动态生成路径，或者使用了lazy-once模式），[index]和[request]就不会被使用了。

	/**
		个人理解，应该是：它是用来生成 新chunk的名字 的。
	*/

//=================================================================== 预先拉取（prefetching）和预先加载（preloading）
//=================================================================== 预先拉取（prefetching）和预先加载（preloading）
Webpack 4.6.0 为我们提供了预先拉取（prefetching）和预先加载（preloading）的功能。
使用这些声明可以 修改浏览器 处理 异步chunk的 方式。

	/**
		个人理解，应该是：前面讲的是 webpack 怎么对那一类语法打包，生成文件。
						  现在这里说的是：说webpack打包后，浏览器 怎么处理这些异步chunk						  
	*/

//=================================================================== 预先拉取（prefetching）
//=================================================================== 预先拉取（prefetching）

使用预先拉取，你表示该模块可能以后会用到。
浏览器会在空闲时间下载该模块，且下载是发生在父级chunk加载完成之后。
	/**
		个人理解，应该是： 空间时间下载载这个 "异步chunk"，前提是 父级chunk 加载完成。
	*/
	用法示例：
	
	import(
	  `./utilities/divide`
	  
	  /* webpackPrefetch: true */               ***************这个
	  
	  /* webpackChunkName: "utilities" */
	)

	以上的导入会让<link rel="prefetch" as="script" href="utilities.js">被添加至页面的头部。
	因此浏览器会在空闲时间预先拉取该文件。


//=================================================================== 预先加载（preloading）
//=================================================================== 预先加载（preloading）

在资源上添加 "预先加载" 的注释，
你指明该模块需要立即被使用。
异步chunk会 和 父级chunk并行加载。
如果父级chunk先下载好，页面就已可显示了，
同时等待异步chunk的下载。这能大幅提升性能。　　
	/**
		个人理解，应该是： "预先加载"，就是提前加载，提前准备好。
	*/
	import(
		  `./utilities/divide`

		  /* webpackPreload: true */			***************这个

		  /* webpackChunkName: "utilities" */

	)
	
	
以上代码的效果是让<link rel="preload" as="script" href="utilities.js">起作用。
不当地使用wepbackPreload会损害性能，所以使用的时候要小心。


//================================================================================== 总结
//================================================================================== 总结

这次我们学习了如何使用动态导入提升应用的性能。它们能显著减少页面的初次加载时间。
使用可传入Webpack的额外参数，你可以更进一步地定制它，并且添加上对预先拉取和预先加载的支持。
所有这些，都会优化你的用户体验，让你的网站更加灵动。


	